{
  "version": 3,
  "sources": ["../index.ts", "../lib/graph.ts", "../lib/version.ts", "../lib/json.ts", "../lib/alg/index.ts", "../lib/alg/bellman-ford.ts", "../lib/alg/components.ts", "../lib/data/priority-queue.ts", "../lib/alg/dijkstra.ts", "../lib/alg/dijkstra-all.ts", "../lib/alg/tarjan.ts", "../lib/alg/find-cycles.ts", "../lib/alg/floyd-warshall.ts", "../lib/alg/topsort.ts", "../lib/alg/is-acyclic.ts", "../lib/alg/reduce.ts", "../lib/alg/dfs.ts", "../lib/alg/postorder.ts", "../lib/alg/preorder.ts", "../lib/alg/prim.ts", "../lib/alg/shortest-paths.ts"],
  "sourcesContent": ["/**\n * Copyright (c) 2014, Chris Pettitt\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors\n * may be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nexport {Graph} from './lib/graph';\nexport {version} from './lib/version';\nexport * as json from './lib/json';\nexport * as alg from './lib/alg/index';\n\nexport type {GraphOptions, Edge, Path, WeightFunction, EdgeFunction} from './lib/types.js';\n", "import type {Edge, EdgeLabelFactory, GraphOptions, NodeLabelFactory} from './types';\n\nconst DEFAULT_EDGE_NAME = \"\\x00\";\nconst GRAPH_NODE = \"\\x00\";\nconst EDGE_KEY_DELIM = \"\\x01\";\n\n// Implementation notes:\n//\n//  * Node id query functions should return string ids for the nodes\n//  * Edge id query functions should return an \"edgeObj\", edge object, that is\n//    composed of enough information to uniquely identify an edge: {v, w, name}.\n//  * Internally we use an \"edgeId\", a stringified form of the edgeObj, to\n//    reference edges. This is because we need a performant way to look these\n//    edges up and, object properties, which have string keys, are the closest\n//    we're going to get to a performant hashtable in JavaScript.\n\nexport class Graph<GraphLabel = any, NodeLabel = any, EdgeLabel = any> {\n    private _isDirected: boolean = true;\n    private _isMultigraph: boolean = false;\n    private _isCompound: boolean = false;\n\n    // Label for the graph itself\n    private _label!: GraphLabel;\n    // v -> label\n    private _nodes: Record<string, NodeLabel> = {};\n    // v -> edgeObj\n    private _in: Record<string, Record<string, Edge>> = {};\n    // u -> v -> Number\n    private _preds: Record<string, Record<string, number>> = {};\n    // v -> edgeObj\n    private _out: Record<string, Record<string, Edge>> = {};\n    // v -> w -> Number\n    private _sucs: Record<string, Record<string, number>> = {};\n    // e -> edgeObj\n    private _edgeObjs: Record<string, Edge> = {};\n    // e -> label\n    private _edgeLabels: Record<string, EdgeLabel> = {};\n    /* Number of nodes in the graph. Should only be changed by the implementation. */\n    private _nodeCount: number = 0;\n    /* Number of edges in the graph. Should only be changed by the implementation. */\n    private _edgeCount: number = 0;\n    private _parent?: Record<string, string>;\n    private _children?: Record<string, Record<string, boolean>>;\n\n    constructor(opts?: GraphOptions) {\n        if (opts) {\n            this._isDirected = \"directed\" in opts ? opts.directed! : true;\n            this._isMultigraph = \"multigraph\" in opts ? opts.multigraph! : false;\n            this._isCompound = \"compound\" in opts ? opts.compound! : false;\n        }\n\n        if (this._isCompound) {\n            // v -> parent\n            this._parent = {};\n\n            // v -> children\n            this._children = {};\n            this._children[GRAPH_NODE] = {};\n        }\n    }\n\n    /**\n     * Whether graph was created with 'directed' flag set to true or not.\n     *\n     * @returns whether the graph edges have an orientation.\n     */\n    isDirected(): boolean {\n        return this._isDirected;\n    }\n\n    /**\n     * Whether graph was created with 'multigraph' flag set to true or not.\n     *\n     * @returns whether the pair of nodes of the graph can have multiple edges.\n     */\n    isMultigraph(): boolean {\n        return this._isMultigraph;\n    }\n\n    /* === Graph functions ========= */\n\n    /**\n     * Whether graph was created with 'compound' flag set to true or not.\n     *\n     * @returns whether a node of the graph can have subnodes.\n     */\n    isCompound(): boolean {\n        return this._isCompound;\n    }\n\n    /**\n     * Sets the label of the graph.\n     *\n     * @param label - label value.\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    setGraph(label: GraphLabel): this {\n        this._label = label;\n        return this;\n    }\n\n    /**\n     * Gets the graph label.\n     *\n     * @returns currently assigned label for the graph or undefined if no label assigned.\n     */\n    graph(): GraphLabel {\n        // TODO: This should return undefined if no label was assigned, but that would be a breaking change.\n        return this._label;\n    }\n\n    /**\n     * Sets the default node label. This label will be assigned as default label\n     * in case if no label was specified while setting a node.\n     * Complexity: O(1).\n     *\n     * @param labelOrFn - default node label or label factory function.\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    setDefaultNodeLabel(labelOrFn: NodeLabel | NodeLabelFactory<NodeLabel>): this {\n        if (typeof labelOrFn !== 'function') {\n            this._defaultNodeLabelFn = () => labelOrFn;\n        } else {\n            this._defaultNodeLabelFn = labelOrFn as NodeLabelFactory<NodeLabel>;\n        }\n\n        return this;\n    }\n\n    /**\n     * Gets the number of nodes in the graph.\n     * Complexity: O(1).\n     *\n     * @returns nodes count.\n     */\n    nodeCount(): number {\n        return this._nodeCount;\n    }\n\n\n    /* === Node functions ========== */\n\n    /**\n     * Gets all nodes of the graph. Note, the in case of compound graph subnodes are\n     * not included in list.\n     * Complexity: O(1).\n     *\n     * @returns list of graph nodes.\n     */\n    nodes(): string[] {\n        return Object.keys(this._nodes);\n    }\n\n    /**\n     * Gets list of nodes without in-edges.\n     * Complexity: O(|V|).\n     *\n     * @returns the graph source nodes.\n     */\n    sources(): string[] {\n        return this.nodes().filter(v => Object.keys(this._in[v]!).length === 0);\n    }\n\n    /**\n     * Gets list of nodes without out-edges.\n     * Complexity: O(|V|).\n     *\n     * @returns the graph sink nodes.\n     */\n    sinks(): string[] {\n        return this.nodes().filter(v => Object.keys(this._out[v]!).length === 0);\n    }\n\n    /**\n     * Invokes setNode method for each node in names list.\n     * Complexity: O(|names|).\n     *\n     * @param names - list of nodes names to be set.\n     * @param label - value to set for each node in list.\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    setNodes(names: string[], label?: NodeLabel): this {\n        names.forEach((v) => {\n            if (label !== undefined) {\n                this.setNode(v, label);\n            } else {\n                this.setNode(v);\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Creates or updates the value for the node v in the graph. If label is supplied\n     * it is set as the value for the node. If label is not supplied and the node was\n     * created by this call then the default node label will be assigned.\n     * Complexity: O(1).\n     *\n     * @param name - node name.\n     * @param label - value to set for node.\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    setNode(name: string, label?: NodeLabel): this {\n        if (name in this._nodes) {\n            if (arguments.length > 1) {\n                this._nodes[name] = label!;\n            }\n            return this;\n        }\n\n        this._nodes[name] = arguments.length > 1 ? label! : this._defaultNodeLabelFn(name);\n        if (this._isCompound) {\n            this._parent![name] = GRAPH_NODE;\n            this._children![name] = {};\n            this._children![GRAPH_NODE]![name] = true;\n        }\n        this._in[name] = {};\n        this._preds[name] = {};\n        this._out[name] = {};\n        this._sucs[name] = {};\n        ++this._nodeCount;\n        return this;\n    }\n\n    /**\n     * Gets the label of node with specified name.\n     * Complexity: O(|V|).\n     *\n     * @param name - node name.\n     * @returns label value of the node.\n     */\n    node(name: string): NodeLabel {\n        // TODO: This should return undefined if the node doesn't exist, but that would be a breaking change.\n        return this._nodes[name]!;\n    }\n\n    /**\n     * Detects whether graph has a node with specified name or not.\n     *\n     * @param name - name of the node.\n     * @returns true if graph has node with specified name, false - otherwise.\n     */\n    hasNode(name: string): boolean {\n        return name in this._nodes;\n    }\n\n    /**\n     * Remove the node with the name from the graph or do nothing if the node is not in\n     * the graph. If the node was removed this function also removes any incident\n     * edges.\n     * Complexity: O(1).\n     *\n     * @param name - name of the node.\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    removeNode(name: string): this {\n        if (name in this._nodes) {\n            const removeEdge = (e: string) => this.removeEdge(this._edgeObjs[e]!);\n            delete this._nodes[name];\n            if (this._isCompound) {\n                this._removeFromParentsChildList(name);\n                delete this._parent![name];\n                this.children(name).forEach((child) => {\n                    this.setParent(child);\n                });\n                delete this._children![name];\n            }\n            Object.keys(this._in[name]!).forEach(removeEdge);\n            delete this._in[name];\n            delete this._preds[name];\n            Object.keys(this._out[name]!).forEach(removeEdge);\n            delete this._out[name];\n            delete this._sucs[name];\n            --this._nodeCount;\n        }\n        return this;\n    }\n\n    /**\n     * Sets node parent for node v if it is defined, or removes the\n     * parent for v if p is undefined. Method throws an exception in case of\n     * invoking it in context of noncompound graph.\n     * Average-case complexity: O(1).\n     *\n     * @param v - node to be child for p.\n     * @param parent - node to be parent for v.\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    setParent(v: string, parent?: string): this {\n        if (!this._isCompound) {\n            throw new Error(\"Cannot set parent in a non-compound graph\");\n        }\n\n        if (parent === undefined) {\n            parent = GRAPH_NODE;\n        } else {\n            // Coerce parent to string\n            parent += \"\";\n            for (let ancestor: string | undefined | void = parent; ancestor !== undefined; ancestor = this.parent(ancestor)) {\n                if (ancestor === v) {\n                    throw new Error(\"Setting \" + parent + \" as parent of \" + v +\n                        \" would create a cycle\");\n                }\n            }\n\n            this.setNode(parent);\n        }\n\n        this.setNode(v);\n        this._removeFromParentsChildList(v);\n        this._parent![v] = parent;\n        this._children![parent]![v] = true;\n        return this;\n    }\n\n    /**\n     * Gets parent node for node v.\n     * Complexity: O(1).\n     *\n     * @param v - node to get parent of.\n     * @returns parent node name or void if v has no parent.\n     */\n    parent(v: string): string | void {\n        if (this._isCompound) {\n            const parent = this._parent![v];\n            if (parent !== GRAPH_NODE) {\n                return parent;\n            }\n        }\n    }\n\n    /**\n     * Gets list of direct children of node v.\n     * Complexity: O(1).\n     *\n     * @param v - node to get children of.\n     * @returns children nodes names list.\n     */\n    children(v: string = GRAPH_NODE): string[] {\n        if (this._isCompound) {\n            const children = this._children![v];\n            if (children) {\n                return Object.keys(children);\n            }\n        } else if (v === GRAPH_NODE) {\n            return this.nodes();\n        } else if (this.hasNode(v)) {\n            return [];\n        }\n        return [];\n    }\n\n    /**\n     * Return all nodes that are predecessors of the specified node or undefined if node v is not in\n     * the graph. Behavior is undefined for undirected graphs - use neighbors instead.\n     * Complexity: O(|V|).\n     *\n     * @param v - node identifier.\n     * @returns node identifiers list or undefined if v is not in the graph.\n     */\n    predecessors(v: string): void | string[] {\n        const predsV = this._preds[v];\n        if (predsV) {\n            return Object.keys(predsV);\n        }\n    }\n\n    /**\n     * Return all nodes that are successors of the specified node or undefined if node v is not in\n     * the graph. Behavior is undefined for undirected graphs - use neighbors instead.\n     * Complexity: O(|V|).\n     *\n     * @param v - node identifier.\n     * @returns node identifiers list or undefined if v is not in the graph.\n     */\n    successors(v: string): void | string[] {\n        const sucsV = this._sucs[v];\n        if (sucsV) {\n            return Object.keys(sucsV);\n        }\n    }\n\n    /**\n     * Return all nodes that are predecessors or successors of the specified node or undefined if\n     * node v is not in the graph.\n     * Complexity: O(|V|).\n     *\n     * @param v - node identifier.\n     * @returns node identifiers list or undefined if v is not in the graph.\n     */\n    neighbors(v: string): void | string[] {\n        const preds = this.predecessors(v);\n        if (preds) {\n            const union = new Set(preds);\n            for (const succ of this.successors(v)!) {\n                union.add(succ);\n            }\n\n            return Array.from(union.values());\n        }\n    }\n\n    isLeaf(v: string): boolean {\n        let neighbors: string[] | void;\n        if (this.isDirected()) {\n            neighbors = this.successors(v);\n        } else {\n            neighbors = this.neighbors(v);\n        }\n        return neighbors!.length === 0;\n    }\n\n    /**\n     * Creates new graph with nodes filtered via filter. Edges incident to rejected node\n     * are also removed. In case of compound graph, if parent is rejected by filter,\n     * than all its children are rejected too.\n     * Average-case complexity: O(|E|+|V|).\n     *\n     * @param filter - filtration function detecting whether the node should stay or not.\n     * @returns new graph made from current and nodes filtered.\n     */\n    filterNodes(filter: (v: string) => boolean): this {\n        const copy = new (this.constructor as typeof Graph<GraphLabel, NodeLabel, EdgeLabel>)({\n            directed: this._isDirected,\n            multigraph: this._isMultigraph,\n            compound: this._isCompound\n        });\n\n        copy.setGraph(this.graph()!);\n\n        Object.entries(this._nodes).forEach(([v, value]) => {\n            if (filter(v)) {\n                copy.setNode(v, value);\n            }\n        });\n\n        Object.values(this._edgeObjs).forEach((e) => {\n            if (copy.hasNode(e.v) && copy.hasNode(e.w)) {\n                copy.setEdge(e, this.edge(e));\n            }\n        });\n\n        const parents: Record<string, string | undefined> = {};\n        const findParent = (v: string): string | undefined => {\n            const parent = this.parent(v);\n            if (!parent || copy.hasNode(parent)) {\n                parents[v] = parent ?? undefined;\n                return parent ?? undefined;\n            } else if (parent in parents) {\n                return parents[parent];\n            } else {\n                return findParent(parent);\n            }\n        };\n\n        if (this._isCompound) {\n            copy.nodes().forEach(v => copy.setParent(v, findParent(v)));\n        }\n\n        return copy as this;\n    }\n\n    /**\n     * Sets the default edge label. This label will be assigned as default label\n     * in case if no label was specified while setting an edge.\n     * Complexity: O(1).\n     *\n     * @param labelOrFn - default edge label or label factory function.\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    setDefaultEdgeLabel(labelOrFn: EdgeLabel | EdgeLabelFactory<EdgeLabel>): this {\n        if (typeof labelOrFn !== 'function') {\n            this._defaultEdgeLabelFn = () => labelOrFn;\n        } else {\n            this._defaultEdgeLabelFn = labelOrFn as EdgeLabelFactory<EdgeLabel>;\n        }\n\n        return this;\n    }\n\n    /**\n     * Gets the number of edges in the graph.\n     * Complexity: O(1).\n     *\n     * @returns edges count.\n     */\n    edgeCount(): number {\n        return this._edgeCount;\n    }\n\n    /**\n     * Gets edges of the graph. In case of compound graph subgraphs are not considered.\n     * Complexity: O(|E|).\n     *\n     * @returns graph edges list.\n     */\n    edges(): Edge[] {\n        return Object.values(this._edgeObjs);\n    }\n\n    /* === Edge functions ========== */\n\n    /**\n     * Establish an edges path over the nodes in nodes list. If some edge is already\n     * exists, it will update its label, otherwise it will create an edge between pair\n     * of nodes with label provided or default label if no label provided.\n     * Complexity: O(|nodes|).\n     *\n     * @param nodes - list of nodes to be connected in series.\n     * @param label - value to set for each edge between pairs of nodes.\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    setPath(nodes: string[], label?: EdgeLabel): this {\n        nodes.reduce((v, w) => {\n            if (label !== undefined) {\n                this.setEdge(v, w, label);\n            } else {\n                this.setEdge(v, w);\n            }\n            return w;\n        });\n        return this;\n    }\n\n    /**\n     * Creates or updates the label for the edge (v, w) with the optionally supplied\n     * name. If label is supplied it is set as the value for the edge. If label is not\n     * supplied and the edge was created by this call then the default edge label will\n     * be assigned. The name parameter is only useful with multigraphs.\n     * Complexity: O(1).\n     *\n     * @param v - edge source node.\n     * @param w - edge sink node.\n     * @param label - value to associate with the edge.\n     * @param name - unique name of the edge in order to identify it in multigraph.\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    setEdge(v: string, w: string, label?: EdgeLabel, name?: string): this;\n\n    /**\n     * Creates or updates the label for the specified edge. If label is supplied it is\n     * set as the value for the edge. If label is not supplied and the edge was created\n     * by this call then the default edge label will be assigned. The name parameter is\n     * only useful with multigraphs.\n     * Complexity: O(1).\n     *\n     * @param edge - edge descriptor.\n     * @param label - value to associate with the edge.\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    setEdge(edge: Edge, label?: EdgeLabel): this;\n\n    setEdge(v: string | Edge, w?: string | EdgeLabel, value?: EdgeLabel, name?: string): this {\n        let vStr: string;\n        let wStr: string;\n        let nameStr: string | undefined;\n        let edgeValue: EdgeLabel | undefined;\n        let valueSpecified = false;\n\n        if (typeof v === \"object\" && v !== null && \"v\" in v) {\n            vStr = v.v;\n            wStr = v.w;\n            nameStr = v.name;\n            if (arguments.length === 2) {\n                edgeValue = w as EdgeLabel;\n                valueSpecified = true;\n            }\n        } else {\n            vStr = v;\n            wStr = w as string;\n            nameStr = name;\n            if (arguments.length > 2) {\n                edgeValue = value;\n                valueSpecified = true;\n            }\n        }\n\n        vStr = \"\" + vStr;\n        wStr = \"\" + wStr;\n        if (nameStr !== undefined) {\n            nameStr = \"\" + nameStr;\n        }\n\n        const e = edgeArgsToId(this._isDirected, vStr, wStr, nameStr);\n        if (e in this._edgeLabels) {\n            if (valueSpecified) {\n                this._edgeLabels[e] = edgeValue!;\n            }\n            return this;\n        }\n\n        if (nameStr !== undefined && !this._isMultigraph) {\n            throw new Error(\"Cannot set a named edge when isMultigraph = false\");\n        }\n\n        // It didn't exist, so we need to create it.\n        // First ensure the nodes exist.\n        this.setNode(vStr);\n        this.setNode(wStr);\n\n        this._edgeLabels[e] = valueSpecified ? edgeValue! : this._defaultEdgeLabelFn(vStr, wStr, nameStr);\n\n        // Ensure we add undirected edges in a consistent way.\n        const edgeObj = edgeArgsToObj(this._isDirected, vStr, wStr, nameStr);\n\n        vStr = edgeObj.v;\n        wStr = edgeObj.w;\n\n        Object.freeze(edgeObj);\n        this._edgeObjs[e] = edgeObj;\n        incrementOrInitEntry(this._preds[wStr]!, vStr);\n        incrementOrInitEntry(this._sucs[vStr]!, wStr);\n        this._in[wStr]![e] = edgeObj;\n        this._out[vStr]![e] = edgeObj;\n        this._edgeCount++;\n        return this;\n    }\n\n    /**\n     * Gets the label for the specified edge.\n     * Complexity: O(1).\n     *\n     * @param v - edge source node.\n     * @param w - edge sink node.\n     * @param name - name of the edge (actual for multigraph).\n     * @returns value associated with specified edge.\n     */\n    edge(v: string, w: string, name?: string): EdgeLabel;\n\n    /**\n     * Gets the label for the specified edge.\n     * Complexity: O(1).\n     *\n     * @param edge - edge descriptor.\n     * @returns value associated with specified edge.\n     */\n    edge(edge: Edge): EdgeLabel;\n\n    edge(v: string | Edge, w?: string, name?: string): EdgeLabel {\n        // TODO: This should return undefined if the edge doesn't exist, but that would be a breaking change.\n        const e = (arguments.length === 1\n            ? edgeObjToId(this._isDirected, v as Edge)\n            : edgeArgsToId(this._isDirected, v as string, w!, name));\n        return this._edgeLabels[e]!;\n    }\n\n    /**\n     * Gets the label for the specified edge and converts it to an object.\n     * Complexity: O(1).\n     *\n     * @param v - edge source node.\n     * @param w - edge sink node.\n     * @param name - name of the edge (actual for multigraph).\n     * @returns value associated with specified edge.\n     */\n    edgeAsObj(v: string, w: string, name?: string): { label: EdgeLabel };\n\n    /**\n     * Gets the label for the specified edge and converts it to an object.\n     * Complexity: O(1).\n     *\n     * @param edge - edge descriptor.\n     * @returns value associated with specified edge.\n     */\n    edgeAsObj(edge: Edge): { label: EdgeLabel };\n\n    edgeAsObj(v: string | Edge, w?: string, name?: string): { label: EdgeLabel } {\n        const edgeLabel = arguments.length === 1\n            ? this.edge(v as Edge)\n            : this.edge(v as string, w!, name);\n\n        if (typeof edgeLabel !== \"object\") {\n            return {label: edgeLabel as EdgeLabel};\n        }\n\n        return edgeLabel as { label: EdgeLabel };\n    }\n\n    /**\n     * Detects whether the graph contains specified edge or not. No subgraphs are considered.\n     * Complexity: O(1).\n     *\n     * @param v - edge source node.\n     * @param w - edge sink node.\n     * @param name - name of the edge (actual for multigraph).\n     * @returns whether the graph contains the specified edge or not.\n     */\n    hasEdge(v: string, w: string, name?: string): boolean;\n\n    /**\n     * Detects whether the graph contains specified edge or not. No subgraphs are considered.\n     * Complexity: O(1).\n     *\n     * @param edge - edge descriptor.\n     * @returns whether the graph contains the specified edge or not.\n     */\n    hasEdge(edge: Edge): boolean;\n\n    hasEdge(v: string | Edge, w?: string, name?: string): boolean {\n        const e = (arguments.length === 1\n            ? edgeObjToId(this._isDirected, v as Edge)\n            : edgeArgsToId(this._isDirected, v as string, w!, name));\n        return e in this._edgeLabels;\n    }\n\n    /**\n     * Removes the specified edge from the graph. No subgraphs are considered.\n     * Complexity: O(1).\n     *\n     * @param v - edge source node.\n     * @param w - edge sink node.\n     * @param name - name of the edge (actual for multigraph).\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    removeEdge(v: string, w: string, name?: string): this;\n\n    /**\n     * Removes the specified edge from the graph. No subgraphs are considered.\n     * Complexity: O(1).\n     *\n     * @param edge - edge descriptor.\n     * @returns the graph, allowing this to be chained with other functions.\n     */\n    removeEdge(edge: Edge): this;\n\n    removeEdge(v: string | Edge, w?: string, name?: string): this {\n        const e = (arguments.length === 1\n            ? edgeObjToId(this._isDirected, v as Edge)\n            : edgeArgsToId(this._isDirected, v as string, w!, name));\n        const edge = this._edgeObjs[e];\n        if (edge) {\n            const vStr = edge.v;\n            const wStr = edge.w;\n            delete this._edgeLabels[e];\n            delete this._edgeObjs[e];\n            decrementOrRemoveEntry(this._preds[wStr]!, vStr);\n            decrementOrRemoveEntry(this._sucs[vStr]!, wStr);\n            delete this._in[wStr]![e];\n            delete this._out[vStr]![e];\n            this._edgeCount--;\n        }\n        return this;\n    }\n\n    /**\n     * Return all edges that point to the node v. Optionally filters those edges down to just those\n     * coming from node u. Behavior is void for undirected graphs - use nodeEdges instead.\n     * Complexity: O(|E|).\n     *\n     * @param v - edge sink node.\n     * @param w - edge source node.\n     * @returns edges descriptors list if v is in the graph, or void otherwise.\n     */\n    inEdges(v: string, w?: string): void | Edge[] {\n        if (this.isDirected()) {\n            return this.filterEdges(this._in[v], v, w);\n        }\n        return this.nodeEdges(v, w);\n    }\n\n    /**\n     * Return all edges that are pointed at by node v. Optionally filters those edges down to just\n     * those point to w. Behavior is void for undirected graphs - use nodeEdges instead.\n     * Complexity: O(|E|).\n     *\n     * @param v - edge source node.\n     * @param w - edge sink node.\n     * @returns edges descriptors list if v is in the graph, or void otherwise.\n     */\n    outEdges(v: string, w?: string): void | Edge[] {\n        if (this.isDirected()) {\n            return this.filterEdges(this._out[v], v, w);\n        }\n        return this.nodeEdges(v, w);\n    }\n\n    /**\n     * Returns all edges to or from node v regardless of direction. Optionally filters those edges\n     * down to just those between nodes v and w regardless of direction.\n     * Complexity: O(|E|).\n     *\n     * @param v - edge adjacent node.\n     * @param w - edge adjacent node.\n     * @returns edges descriptors list if v is in the graph, or void otherwise.\n     */\n    nodeEdges(v: string, w?: string): void | Edge[] {\n        if (v in this._nodes) {\n            return this.filterEdges({...this._in[v]!, ...this._out[v]!}, v, w);\n        }\n    }\n\n    // Defaults to be set when creating a new node\n    private _defaultNodeLabelFn: NodeLabelFactory<NodeLabel> = () => undefined as NodeLabel;\n\n    // Defaults to be set when creating a new edge\n    private _defaultEdgeLabelFn: EdgeLabelFactory<EdgeLabel> = () => undefined as EdgeLabel;\n\n    private _removeFromParentsChildList(v: string): void {\n        delete this._children![this._parent![v]!]![v];\n    }\n\n    private filterEdges(setV: Record<string, Edge> | undefined, localEdge: string, remoteEdge?: string): Edge[] | undefined {\n        if (!setV) {\n            return;\n        }\n        const edges = Object.values(setV);\n        if (!remoteEdge) {\n            return edges;\n        }\n        return edges.filter((edge) => {\n            return edge.v === localEdge && edge.w === remoteEdge\n                || edge.v === remoteEdge && edge.w === localEdge;\n        });\n    }\n}\n\n\nfunction incrementOrInitEntry(map: Record<string, number>, k: string): void {\n    if (map[k]) {\n        map[k]++;\n    } else {\n        map[k] = 1;\n    }\n}\n\nfunction decrementOrRemoveEntry(map: Record<string, number>, k: string): void {\n    if (map[k] !== undefined && !--map[k]) {\n        delete map[k];\n    }\n}\n\nfunction edgeArgsToId(isDirected: boolean, v_: string, w_: string, name?: string): string {\n    let v = \"\" + v_;\n    let w = \"\" + w_;\n    if (!isDirected && v > w) {\n        const tmp = v;\n        v = w;\n        w = tmp;\n    }\n    return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +\n        (name === undefined ? DEFAULT_EDGE_NAME : name);\n}\n\nfunction edgeArgsToObj(isDirected: boolean, v_: string, w_: string, name?: string): Edge {\n    let v = \"\" + v_;\n    let w = \"\" + w_;\n    if (!isDirected && v > w) {\n        const tmp = v;\n        v = w;\n        w = tmp;\n    }\n    const edgeObj: Edge = {v: v, w: w};\n    if (name) {\n        edgeObj.name = name;\n    }\n    return edgeObj;\n}\n\nfunction edgeObjToId(isDirected: boolean, edgeObj: Edge): string {\n    return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);\n}\n", "export const version = '4.0.0-pre';\n", "import {Graph} from './graph';\nimport type {GraphOptions} from './types';\n\ninterface JsonGraph {\n    options: GraphOptions;\n    nodes: JsonNode[];\n    edges: JsonEdge[];\n    value?: unknown;\n}\n\ninterface JsonNode {\n    v: string;\n    value?: unknown;\n    parent?: string;\n}\n\ninterface JsonEdge {\n    v: string;\n    w: string;\n    name?: string;\n    value?: unknown;\n}\n\n/**\n * Creates a JSON representation of the graph that can be serialized to a string with\n * JSON.stringify. The graph can later be restored using json.read.\n *\n * @param graph - target to create JSON representation of.\n * @returns JSON serializable graph representation\n */\nexport function write(graph: Graph): JsonGraph {\n    const json: JsonGraph = {\n        options: {\n            directed: graph.isDirected(),\n            multigraph: graph.isMultigraph(),\n            compound: graph.isCompound()\n        },\n        nodes: writeNodes(graph),\n        edges: writeEdges(graph)\n    };\n\n    const graphLabel = graph.graph();\n    if (graphLabel !== undefined) {\n        json.value = structuredClone(graphLabel);\n    }\n\n    return json;\n}\n\nfunction writeNodes(g: Graph): JsonNode[] {\n    return g.nodes().map(v => {\n        const nodeValue = g.node(v);\n        const parent = g.parent(v);\n        const node: JsonNode = {v};\n\n        if (nodeValue !== undefined) {\n            node.value = nodeValue;\n        }\n        if (parent !== undefined) {\n            node.parent = parent;\n        }\n\n        return node;\n    });\n}\n\nfunction writeEdges(g: Graph): JsonEdge[] {\n    return g.edges().map(e => {\n        const edgeValue = g.edge(e);\n        const edge: JsonEdge = {v: e.v, w: e.w};\n\n        if (e.name !== undefined) {\n            edge.name = e.name;\n        }\n        if (edgeValue !== undefined) {\n            edge.value = edgeValue;\n        }\n\n        return edge;\n    });\n}\n\n/**\n * Takes JSON as input and returns the graph representation.\n *\n * @param json - JSON serializable graph representation\n * @returns graph constructed according to specified representation\n *\n * @example\n * var g2 = graphlib.json.read(JSON.parse(str));\n * g2.nodes();\n * // ['a', 'b']\n * g2.edges()\n * // [ { v: 'a', w: 'b' } ]\n */\nexport function read<GraphLabel = any, NodeLabel = any, EdgeLabel = any>(\n    json: JsonGraph\n): Graph<GraphLabel, NodeLabel, EdgeLabel> {\n    const g = new Graph<GraphLabel, NodeLabel, EdgeLabel>(json.options);\n\n    if (json.value !== undefined) {\n        g.setGraph(json.value as GraphLabel);\n    }\n\n    json.nodes.forEach(entry => {\n        g.setNode(entry.v, entry.value as NodeLabel);\n        if (entry.parent) {\n            g.setParent(entry.v, entry.parent);\n        }\n    });\n\n    json.edges.forEach(entry => {\n        g.setEdge({v: entry.v, w: entry.w, name: entry.name}, entry.value as EdgeLabel);\n    });\n\n    return g;\n}\n", "export {bellmanFord} from './bellman-ford';\nexport {components} from './components';\nexport {dijkstra} from './dijkstra';\nexport {dijkstraAll} from './dijkstra-all';\nexport {findCycles} from './find-cycles';\nexport {floydWarshall} from './floyd-warshall';\nexport {isAcyclic} from './is-acyclic';\nexport {postorder} from './postorder';\nexport {preorder} from './preorder';\nexport {prim} from './prim';\nexport {shortestPaths} from './shortest-paths';\nexport {tarjan} from './tarjan';\nexport {topsort, CycleException} from './topsort';\n", "import {Graph} from '../graph';\nimport type {Edge, EdgeFunction, Path, WeightFunction} from '../types';\n\nconst DEFAULT_WEIGHT_FUNC: WeightFunction = () => 1;\n\nexport function bellmanFord(\n    g: Graph,\n    source: string,\n    weightFn?: WeightFunction,\n    edgeFn?: EdgeFunction\n): Record<string, Path> {\n    return runBellmanFord(\n        g,\n        String(source),\n        weightFn || DEFAULT_WEIGHT_FUNC,\n        edgeFn || function (v) {\n            return g.outEdges(v)!;\n        }\n    );\n}\n\nfunction runBellmanFord(\n    g: Graph,\n    source: string,\n    weightFn: WeightFunction,\n    edgeFn: EdgeFunction\n): Record<string, Path> {\n    const results: Record<string, Path> = {};\n    let didADistanceUpgrade: boolean;\n    let iterations = 0;\n    const nodes = g.nodes();\n\n    const relaxEdge = function (edge: Edge): void {\n        const edgeWeight = weightFn(edge);\n        if (results[edge.v]!.distance + edgeWeight < results[edge.w]!.distance) {\n            results[edge.w] = {\n                distance: results[edge.v]!.distance + edgeWeight,\n                predecessor: edge.v\n            };\n            didADistanceUpgrade = true;\n        }\n    };\n\n    const relaxAllEdges = function (): void {\n        nodes.forEach(function (vertex) {\n            edgeFn(vertex).forEach(function (edge) {\n                // If the vertex on which the edgeFun in called is\n                // the edge.w, then we treat the edge as if it was reversed\n                const inVertex = edge.v === vertex ? edge.v : edge.w;\n                const outVertex = inVertex === edge.v ? edge.w : edge.v;\n                relaxEdge({v: inVertex, w: outVertex});\n            });\n        });\n    };\n\n    // Initialization\n    nodes.forEach(function (v) {\n        const distance = v === source ? 0 : Number.POSITIVE_INFINITY;\n        results[v] = {distance: distance, predecessor: ''};\n    });\n\n    const numberOfNodes = nodes.length;\n\n    // Relax all edges in |V|-1 iterations\n    for (let i = 1; i < numberOfNodes; i++) {\n        didADistanceUpgrade = false;\n        iterations++;\n        relaxAllEdges();\n        if (!didADistanceUpgrade) {\n            // \u0399f no update was made in an iteration, Bellman-Ford has finished\n            break;\n        }\n    }\n\n    // Detect if the graph contains a negative weight cycle\n    if (iterations === numberOfNodes - 1) {\n        didADistanceUpgrade = false;\n        relaxAllEdges();\n        if (didADistanceUpgrade) {\n            throw new Error(\"The graph contains a negative weight cycle\");\n        }\n    }\n\n    return results;\n}\n", "import {Graph} from '../graph';\n\n/**\n * Finds all connected components in a graph and returns an array of these components.\n * Each component is itself an array that contains the ids of nodes in the component.\n * Complexity: O(|V|).\n *\n * @param graph - graph to find components in.\n * @returns array of nodes list representing components\n */\nexport function components(graph: Graph): string[][] {\n    const visited: Record<string, boolean> = {};\n    const cmpts: string[][] = [];\n    let cmpt: string[];\n\n    function dfs(v: string): void {\n        if (v in visited) return;\n        visited[v] = true;\n        cmpt.push(v);\n        graph.successors(v)!.forEach(dfs);\n        graph.predecessors(v)!.forEach(dfs);\n    }\n\n    graph.nodes().forEach(function (v) {\n        cmpt = [];\n        dfs(v);\n        if (cmpt.length) {\n            cmpts.push(cmpt);\n        }\n    });\n\n    return cmpts;\n}\n", "/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\n\ninterface PriorityQueueEntry {\n    key: string;\n    priority: number;\n}\n\nexport class PriorityQueue {\n    private _arr: PriorityQueueEntry[] = [];\n    private _keyIndices: Record<string, number> = {};\n\n    /**\n     * Returns the number of elements in the queue. Takes `O(1)` time.\n     */\n    size(): number {\n        return this._arr.length;\n    }\n\n    /**\n     * Returns the keys that are in the queue. Takes `O(n)` time.\n     */\n    keys(): string[] {\n        return this._arr.map(x => x.key);\n    }\n\n    /**\n     * Returns `true` if **key** is in the queue and `false` if not.\n     */\n    has(key: string): boolean {\n        return key in this._keyIndices;\n    }\n\n    /**\n     * Returns the priority for **key**. If **key** is not present in the queue\n     * then this function returns `undefined`. Takes `O(1)` time.\n     */\n    priority(key: string): number | undefined {\n        const index = this._keyIndices[key];\n        if (index !== undefined) {\n            return this._arr[index]!.priority;\n        }\n        return undefined;\n    }\n\n    /**\n     * Returns the key for the minimum element in this queue. If the queue is\n     * empty this function throws an Error. Takes `O(1)` time.\n     */\n    min(): string {\n        if (this.size() === 0) {\n            throw new Error(\"Queue underflow\");\n        }\n        return this._arr[0]!.key;\n    }\n\n    /**\n     * Inserts a new key into the priority queue. If the key already exists in\n     * the queue this function returns `false`; otherwise it will return `true`.\n     * Takes `O(n)` time.\n     */\n    add(key: string, priority: number): boolean {\n        const keyIndices = this._keyIndices;\n        const keyStr = String(key);\n\n        if (!(keyStr in keyIndices)) {\n            const arr = this._arr;\n            const index = arr.length;\n            keyIndices[keyStr] = index;\n            arr.push({key: keyStr, priority});\n            this._decrease(index);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n     */\n    removeMin(): string {\n        this._swap(0, this._arr.length - 1);\n        const min = this._arr.pop()!;\n        delete this._keyIndices[min.key];\n        this._heapify(0);\n        return min.key;\n    }\n\n    /**\n     * Decreases the priority for **key** to **priority**. If the new priority is\n     * greater than the previous priority, this function will throw an Error.\n     */\n    decrease(key: string, priority: number): void {\n        const index = this._keyIndices[key];\n        if (index === undefined) {\n            throw new Error(`Key not found: ${key}`);\n        }\n\n        const currentPriority = this._arr[index]!.priority;\n        if (priority > currentPriority) {\n            throw new Error(\n                `New priority is greater than current priority. Key: ${key} Old: ${currentPriority} New: ${priority}`\n            );\n        }\n        this._arr[index]!.priority = priority;\n        this._decrease(index);\n    }\n\n    private _heapify(i: number): void {\n        const arr = this._arr;\n        const l = 2 * i;\n        const r = l + 1;\n        let largest = i;\n\n        if (l < arr.length) {\n            largest = arr[l]!.priority < arr[largest]!.priority ? l : largest;\n            if (r < arr.length) {\n                largest = arr[r]!.priority < arr[largest]!.priority ? r : largest;\n            }\n            if (largest !== i) {\n                this._swap(i, largest);\n                this._heapify(largest);\n            }\n        }\n    }\n\n    private _decrease(index: number): void {\n        const arr = this._arr;\n        const priority = arr[index]!.priority;\n        let parent: number;\n\n        while (index !== 0) {\n            parent = index >> 1;\n            if (arr[parent]!.priority < priority) {\n                break;\n            }\n            this._swap(index, parent);\n            index = parent;\n        }\n    }\n\n    private _swap(i: number, j: number): void {\n        const arr = this._arr;\n        const keyIndices = this._keyIndices;\n        const origArrI = arr[i]!;\n        const origArrJ = arr[j]!;\n\n        arr[i] = origArrJ;\n        arr[j] = origArrI;\n        keyIndices[origArrJ.key] = i;\n        keyIndices[origArrI.key] = j;\n    }\n}\n", "import {Graph} from '../graph';\nimport {PriorityQueue} from '../data/priority-queue';\nimport type {Edge, EdgeFunction, Path, WeightFunction} from '../types';\n\nconst DEFAULT_WEIGHT_FUNC: WeightFunction = () => 1;\n\n/**\n * This function is an implementation of Dijkstra's algorithm which finds the shortest\n * path from source to all other nodes in graph. This function returns a map of\n * v -> { distance, predecessor }. The distance property holds the sum of the weights\n * from source to v along the shortest path or Number.POSITIVE_INFINITY if there is no path\n * from source. The predecessor property can be used to walk the individual elements of the\n * path from source to v in reverse order.\n * Complexity: O((|E| + |V|) * log |V|).\n *\n * @param graph - graph where to search paths.\n * @param source - node to start paths from.\n * @param weightFn - function which takes edge e and returns the weight of it. If no weightFn\n * is supplied then each edge is assumed to have a weight of 1. This function throws an\n * Error if any of the traversed edges have a negative edge weight.\n * @param edgeFn - function which takes a node v and returns the ids of all edges incident to it\n * for the purposes of shortest path traversal. By default this function uses the graph.outEdges.\n * @returns shortest paths map that starts from node source\n */\nexport function dijkstra(\n    graph: Graph,\n    source: string,\n    weightFn?: WeightFunction,\n    edgeFn?: EdgeFunction\n): Record<string, Path> {\n    const defaultEdgeFn: EdgeFunction = function (v) {\n        return graph.outEdges(v)!;\n    };\n\n    return runDijkstra(graph, String(source),\n        weightFn || DEFAULT_WEIGHT_FUNC,\n        edgeFn || defaultEdgeFn);\n}\n\nfunction runDijkstra(\n    graph: Graph,\n    source: string,\n    weightFn: WeightFunction,\n    edgeFn: EdgeFunction\n): Record<string, Path> {\n    const results: Record<string, Path> = {};\n    const pq = new PriorityQueue();\n    let v: string, vEntry: Path;\n\n    const updateNeighbors = function (edge: Edge): void {\n        const w = edge.v !== v ? edge.v : edge.w;\n        const wEntry = results[w]!;\n        const weight = weightFn(edge);\n        const distance = vEntry.distance + weight;\n\n        if (weight < 0) {\n            throw new Error(\"dijkstra does not allow negative edge weights. \" +\n                \"Bad edge: \" + edge + \" Weight: \" + weight);\n        }\n\n        if (distance < wEntry.distance) {\n            wEntry.distance = distance;\n            wEntry.predecessor = v;\n            pq.decrease(w, distance);\n        }\n    };\n\n    graph.nodes().forEach(function (v) {\n        const distance = v === source ? 0 : Number.POSITIVE_INFINITY;\n        results[v] = {distance: distance, predecessor: ''};\n        pq.add(v, distance);\n    });\n\n    while (pq.size() > 0) {\n        v = pq.removeMin()!;\n        vEntry = results[v]!;\n        if (vEntry.distance === Number.POSITIVE_INFINITY) {\n            break;\n        }\n\n        edgeFn(v).forEach(updateNeighbors);\n    }\n\n    return results;\n}\n", "import {Graph} from '../graph';\nimport type {EdgeFunction, Path, WeightFunction} from '../types';\nimport {dijkstra} from './dijkstra';\n\n/**\n * This function finds the shortest path from each node to every other reachable node in\n * the graph. It is similar to alg.dijkstra, but instead of returning a single-source\n * array, it returns a mapping of source -> alg.dijkstra(g, source, weightFn, edgeFn).\n * Complexity: O(|V| * (|E| + |V|) * log |V|).\n *\n * @param graph - graph where to search paths.\n * @param weightFn - function which takes edge e and returns the weight of it. If no weightFn\n * is supplied then each edge is assumed to have a weight of 1. This function throws an\n * Error if any of the traversed edges have a negative edge weight.\n * @param edgeFn - function which takes a node v and returns the ids of all edges incident to it\n * for the purposes of shortest path traversal. By default this function uses the graph.outEdges.\n * @returns shortest paths map.\n */\nexport function dijkstraAll(\n    graph: Graph,\n    weightFn?: WeightFunction,\n    edgeFn?: EdgeFunction\n): Record<string, Record<string, Path>> {\n    return graph.nodes().reduce(function (acc, v) {\n        acc[v] = dijkstra(graph, v, weightFn, edgeFn);\n        return acc;\n    }, {} as Record<string, Record<string, Path>>);\n}\n", "import {Graph} from '../graph';\n\ninterface VisitedEntry {\n    onStack: boolean;\n    lowlink: number;\n    index: number;\n}\n\n/**\n * This function is an implementation of Tarjan's algorithm which finds all strongly connected\n * components in the directed graph g. Each strongly connected component is composed of nodes that\n * can reach all other nodes in the component via directed edges. A strongly connected component\n * can consist of a single node if that node cannot both reach and be reached by any other\n * specific node in the graph. Components of more than one node are guaranteed to have at least\n * one cycle.\n * Complexity: O(|V| + |E|).\n *\n * @param graph - graph to find all strongly connected components of.\n * @returns an array of components. Each component is itself an array that contains\n * the ids of all nodes in the component.\n */\nexport function tarjan(graph: Graph): string[][] {\n    let index = 0;\n    const stack: string[] = [];\n    const visited: Record<string, VisitedEntry> = {}; // node id -> { onStack, lowlink, index }\n    const results: string[][] = [];\n\n    function dfs(v: string): void {\n        const entry = visited[v] = {\n            onStack: true,\n            lowlink: index,\n            index: index++\n        };\n        stack.push(v);\n\n        graph.successors(v)!.forEach(function (w) {\n            if (!(w in visited)) {\n                dfs(w);\n                entry.lowlink = Math.min(entry.lowlink, visited[w]!.lowlink);\n            } else if (visited[w]!.onStack) {\n                entry.lowlink = Math.min(entry.lowlink, visited[w]!.index);\n            }\n        });\n\n        if (entry.lowlink === entry.index) {\n            const cmpt: string[] = [];\n            let w: string;\n            do {\n                w = stack.pop()!;\n                visited[w]!.onStack = false;\n                cmpt.push(w);\n            } while (v !== w);\n            results.push(cmpt);\n        }\n    }\n\n    graph.nodes().forEach(function (v) {\n        if (!(v in visited)) {\n            dfs(v);\n        }\n    });\n\n    return results;\n}\n", "import {Graph} from '../graph';\nimport {tarjan} from './tarjan';\n\n/**\n * Given a Graph, graph, this function returns all nodes that are part of a cycle. As there\n * may be more than one cycle in a graph this function return an array of these cycles,\n * where each cycle is itself represented by an array of ids for each node involved in\n * that cycle. Method alg.isAcyclic is more efficient if you only need to determine whether a graph has a\n * cycle or not.\n * Complexity: O(|V| + |E|).\n *\n * @param graph - graph where to search cycles.\n * @returns cycles list.\n */\nexport function findCycles(graph: Graph): string[][] {\n    return tarjan(graph).filter(function (cmpt) {\n        return cmpt.length > 1 || (cmpt.length === 1 && graph.hasEdge(cmpt[0]!, cmpt[0]!));\n    });\n}\n", "import {Graph} from '../graph';\nimport type {EdgeFunction, Path, WeightFunction} from '../types';\n\nconst DEFAULT_WEIGHT_FUNC: WeightFunction = () => 1;\n\n/**\n * This function is an implementation of the Floyd-Warshall algorithm, which finds the\n * shortest path from each node to every other reachable node in the graph. It is similar\n * to alg.dijkstraAll, but it handles negative edge weights and is more efficient for some types\n * of graphs. This function returns a map of source -> { target -> { distance, predecessor }.\n * The distance property holds the sum of the weights from source to target along the shortest\n * path of Number.POSITIVE_INFINITY if there is no path from source. The predecessor property\n * can be used to walk the individual elements of the path from source to target in reverse\n * order.\n * Complexity: O(|V|^3).\n *\n * @param graph - graph where to search paths.\n * @param weightFn - function which takes edge e and returns the weight of it. If no weightFn\n * is supplied then each edge is assumed to have a weight of 1. This function throws an\n * Error if any of the traversed edges have a negative edge weight.\n * @param edgeFn - function which takes a node v and returns the ids of all edges incident to it\n * for the purposes of shortest path traversal. By default this function uses the graph.outEdges.\n * @returns shortest paths map.\n */\nexport function floydWarshall(\n    graph: Graph,\n    weightFn?: WeightFunction,\n    edgeFn?: EdgeFunction\n): Record<string, Record<string, Path>> {\n    return runFloydWarshall(graph,\n        weightFn || DEFAULT_WEIGHT_FUNC,\n        edgeFn || function (v) {\n            return graph.outEdges(v)!;\n        });\n}\n\nfunction runFloydWarshall(\n    graph: Graph,\n    weightFn: WeightFunction,\n    edgeFn: EdgeFunction\n): Record<string, Record<string, Path>> {\n    const results: Record<string, Record<string, Path>> = {};\n    const nodes = graph.nodes();\n\n    nodes.forEach(function (v) {\n        results[v] = {};\n        results[v]![v] = {distance: 0, predecessor: ''};\n        nodes.forEach(function (w) {\n            if (v !== w) {\n                results[v]![w] = {distance: Number.POSITIVE_INFINITY, predecessor: ''};\n            }\n        });\n        edgeFn(v).forEach(function (edge) {\n            const w = edge.v === v ? edge.w : edge.v;\n            const d = weightFn(edge);\n            results[v]![w] = {distance: d, predecessor: v};\n        });\n    });\n\n    nodes.forEach(function (k) {\n        const rowK = results[k]!;\n        nodes.forEach(function (i) {\n            const rowI = results[i]!;\n            nodes.forEach(function (j) {\n                const ik = rowI[k]!;\n                const kj = rowK[j]!;\n                const ij = rowI[j]!;\n                const altDistance = ik.distance + kj.distance;\n                if (altDistance < ij.distance) {\n                    ij.distance = altDistance;\n                    ij.predecessor = kj.predecessor;\n                }\n            });\n        });\n    });\n\n    return results;\n}\n", "import {Graph} from '../graph';\n\nexport class CycleException extends Error {\n    constructor(...args: unknown[]) {\n        super(...args as ConstructorParameters<typeof Error>);\n    }\n}\n\n/**\n * Given a graph this function applies topological sorting to it.\n * If the graph has a cycle it is impossible to generate such a list and CycleException is thrown.\n * Complexity: O(|V| + |E|).\n *\n * @param graph - graph to apply topological sorting to.\n * @returns an array of nodes such that for each edge u -> v, u appears before v in the array.\n */\nexport function topsort(graph: Graph): string[] {\n    const visited: Record<string, boolean> = {};\n    const stack: Record<string, boolean> = {};\n    const results: string[] = [];\n\n    function visit(node: string): void {\n        if (node in stack) {\n            throw new CycleException();\n        }\n\n        if (!(node in visited)) {\n            stack[node] = true;\n            visited[node] = true;\n            graph.predecessors(node)!.forEach(visit);\n            delete stack[node];\n            results.push(node);\n        }\n    }\n\n    graph.sinks().forEach(visit);\n\n    if (Object.keys(visited).length !== graph.nodeCount()) {\n        throw new CycleException();\n    }\n\n    return results;\n}\n", "import {Graph} from '../graph';\nimport {CycleException, topsort} from './topsort';\n\n/**\n * Given a Graph, graph, this function returns true if the graph has no cycles and returns false if it\n * does. This algorithm returns as soon as it detects the first cycle. You can use alg.findCycles\n * to get the actual list of cycles in the graph.\n *\n * @param graph - graph to detect whether it acyclic or not.\n * @returns whether graph contain cycles or not.\n */\nexport function isAcyclic(graph: Graph): boolean {\n    try {\n        topsort(graph);\n    } catch (e) {\n        if (e instanceof CycleException) {\n            return false;\n        }\n        throw e;\n    }\n    return true;\n}\n", "import {Graph} from '../graph';\n\n/*\n * A helper that preforms a pre- or post-order traversal on the input graph\n * and processes the nodes in the order they are visited. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * Order must be one of \"pre\" or \"post\".\n */\nexport function reduce<T>(\n    g: Graph,\n    vs: string | string[],\n    order: string,\n    fn: (acc: T, v: string) => T,\n    acc: T\n): T {\n    if (!Array.isArray(vs)) {\n        vs = [vs];\n    }\n\n    const navigation = ((v: string) => (g.isDirected() ? g.successors(v) : g.neighbors(v)) ?? []);\n\n    const visited: Record<string, boolean> = {};\n    vs.forEach(function (v) {\n        if (!g.hasNode(v)) {\n            throw new Error(\"Graph does not have node: \" + v);\n        }\n\n        acc = doReduce(g, v, order === \"post\", visited, navigation, fn, acc);\n    });\n    return acc;\n}\n\nfunction doReduce<T>(\n    g: Graph,\n    v: string,\n    postorder: boolean,\n    visited: Record<string, boolean>,\n    navigation: (v: string) => string[],\n    fn: (acc: T, v: string) => T,\n    acc: T\n): T {\n    if (!(v in visited)) {\n        visited[v] = true;\n\n        if (!postorder) {\n            acc = fn(acc, v);\n        }\n        navigation(v).forEach(function (w) {\n            acc = doReduce(g, w, postorder, visited, navigation, fn, acc);\n        });\n        if (postorder) {\n            acc = fn(acc, v);\n        }\n    }\n    return acc;\n}\n", "import {Graph} from '../graph';\nimport {reduce} from './reduce';\n\n/*\n * Pre- or post-order traversal on the input graph.\n * Returns an array of the nodes in the order they were visited.\n *\n * If the order is not \"post\", it will be treated as \"pre\".\n */\nexport function dfs(g: Graph, vs: string | string[], order: string): string[] {\n    return reduce(g, vs, order, function (acc, v) {\n        acc.push(v);\n        return acc;\n    }, [] as string[]);\n}\n", "import {Graph} from '../graph';\nimport {dfs} from './dfs';\n\n/**\n * Performs post-order depth first traversal on the input graph. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * @param graph - depth first traversal target.\n * @param vs - nodes list to traverse.\n * @returns the nodes in the order they were visited as a list of their names.\n */\nexport function postorder(graph: Graph, vs: string | string[]): string[] {\n    return dfs(graph, vs, \"post\");\n}\n", "import {Graph} from '../graph';\nimport {dfs} from './dfs';\n\n/**\n * Performs pre-order depth first traversal on the input graph. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * @param graph - depth first traversal target.\n * @param vs - nodes list to traverse.\n * @returns the nodes in the order they were visited as a list of their names.\n */\nexport function preorder(graph: Graph, vs: string | string[]): string[] {\n    return dfs(graph, vs, \"pre\");\n}\n", "import {Graph} from '../graph';\nimport {PriorityQueue} from '../data/priority-queue';\nimport type {Edge, WeightFunction} from '../types';\n\n/**\n * Prim's algorithm takes a connected undirected graph and generates a minimum spanning tree. This\n * function returns the minimum spanning tree as an undirected graph. This algorithm is derived\n * from the description in \"Introduction to Algorithms\", Third Edition, Cormen, et al., Pg 634.\n * Complexity: O(|E| * log |V|);\n *\n * @param graph - graph to generate a minimum spanning tree of.\n * @param weightFn - function which takes edge e and returns the weight of it. It throws an Error if\n * the graph is not connected.\n * @returns minimum spanning tree of graph.\n */\nexport function prim(graph: Graph, weightFn: WeightFunction): Graph {\n    const result = new Graph();\n    const parents: Record<string, string> = {};\n    const pq = new PriorityQueue();\n    let v: string;\n\n    function updateNeighbors(edge: Edge): void {\n        const w = edge.v === v ? edge.w : edge.v;\n        const pri = pq.priority(w);\n        if (pri !== undefined) {\n            const edgeWeight = weightFn(edge);\n            if (edgeWeight < pri) {\n                parents[w] = v;\n                pq.decrease(w, edgeWeight);\n            }\n        }\n    }\n\n    if (graph.nodeCount() === 0) {\n        return result;\n    }\n\n    graph.nodes().forEach(function (v) {\n        pq.add(v, Number.POSITIVE_INFINITY);\n        result.setNode(v);\n    });\n\n    // Start from an arbitrary node\n    pq.decrease(graph.nodes()[0]!, 0);\n\n    let init = false;\n    while (pq.size() > 0) {\n        v = pq.removeMin()!;\n        if (v in parents) {\n            result.setEdge(v, parents[v]!);\n        } else if (init) {\n            throw new Error(\"Input graph is not connected: \" + graph);\n        } else {\n            init = true;\n        }\n\n        graph.nodeEdges(v)!.forEach(updateNeighbors);\n    }\n\n    return result;\n}\n", "import {dijkstra} from './dijkstra';\nimport {bellmanFord} from './bellman-ford';\nimport {Graph} from '../graph';\nimport type {EdgeFunction, Path, WeightFunction} from '../types';\n\nexport function shortestPaths(\n    g: Graph,\n    source: string,\n    weightFn?: WeightFunction,\n    edgeFn?: EdgeFunction\n): Record<string, Path> {\n    return runShortestPaths(\n        g,\n        source,\n        weightFn,\n        edgeFn ?? ((v: string) => {\n            const edges = g.outEdges(v);\n            return edges ?? [];\n        })\n    );\n}\n\nfunction runShortestPaths(\n    g: Graph,\n    source: string,\n    weightFn: WeightFunction | undefined,\n    edgeFn: EdgeFunction\n): Record<string, Path> {\n    if (weightFn === undefined) {\n        return dijkstra(g, source, weightFn, edgeFn);\n    }\n\n    let negativeEdgeExists = false;\n    const nodes = g.nodes();\n\n    for (let i = 0; i < nodes.length; i++) {\n        const adjList = edgeFn(nodes[i]!);\n\n        for (let j = 0; j < adjList.length; j++) {\n            const edge = adjList[j]!;\n            const inVertex = edge.v === nodes[i] ? edge.v : edge.w;\n            const outVertex = inVertex === edge.v ? edge.w : edge.v;\n\n            if (weightFn({v: inVertex, w: outVertex}) < 0) {\n                negativeEdgeExists = true;\n            }\n        }\n\n        if (negativeEdgeExists) {\n            return bellmanFord(g, source, weightFn, edgeFn);\n        }\n    }\n\n    return dijkstra(g, source, weightFn, edgeFn);\n}\n"],
  "mappings": "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",
  "names": ["dfs", "DEFAULT_WEIGHT_FUNC", "v", "dfs", "DEFAULT_WEIGHT_FUNC", "postorder", "v"]
}
